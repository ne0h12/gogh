package gogh

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/scanner"
	"go/token"
	"io"
	"os"
	"runtime/debug"
	"strconv"
	"strings"
)

type straceType struct {
	line   int
	strace string
}

// Renderer a special renderer to take care of go code rendering
type Renderer struct {
	buf        bytes.Buffer
	defaultCtx interface{}

	// lines an amount of lines currently in the buffer
	lines int
	// straces stack traces hare appended before the new
	straces []straceType
}

// WithCtx adds default context for formatting
func WithCtx(r *Renderer, ctx interface{}) {
	if ctx == nil {
		panic(fmt.Errorf("nil context %T added", ctx))
	}
	r.defaultCtx = ctx
}

// Line renders a line with github.com/sirkon/go-format based formatter and the following rules
//   1. If we have no elements in a the line will be saved as is without any formatting
//   2. If we have more than a single element in a `format.Formatp` will be used
//   3. Now, cases on a[0] when a have the single element
//      1. If a[0] implements either error or fmt.Stringer `format.Formatp` will be used
//      2. If a[0] is a slice `format.Formatp(line, a[0]...)` will be used to format this line
//      3. If a[0] is a map[string]interface{} `format.Formatm(line, a[0])` will be used
//      4. If a[0] is a struct or pointer to struct `format.Formatg(line, a[0])` will be used
//      5. If a[0] is a pointer `format.Formatp(a, *a[0])` will be used
//      6. `format.Formatp(line, a[0])` will be used in all cases except listed above
func Line(r *Renderer, line string, a ...interface{}) {
	content := formatLine(line, r.defaultCtx, a...)
	r.buf.WriteString(content)
	r.buf.WriteByte('\n')
	r.straces = append(r.straces, straceType{
		line:   r.lines,
		strace: string(debug.Stack()),
	})
	r.lines += 1 + strings.Count(content, "\n")
}

// Rawl renders a line without format
func Rawl(r *Renderer, line string) {
	r.buf.WriteString(line)
	r.buf.WriteByte('\n')
	r.straces = append(r.straces, straceType{
		line:   r.lines,
		strace: string(debug.Stack()),
	})
	r.lines += 1 + strings.Count(line, "\n")
}

// locateErrorReason look for a stacktrace in a buffer which is a reason of parsing error. codeLine is a position
// in produced code and headerOffset is an amount of lines added before parsing (package statement, imports, comments,
// etc)
func (r *Renderer) locateErrorReason(codeLine int, headerOffset int) (int, string) {
	var strace string
	var line int

	for _, s := range r.straces {
		if s.line+headerOffset <= codeLine {
			line = s.line + headerOffset
			strace = s.strace
		} else {
			break
		}
	}

	return line, strace
}

// Newl renders empty line
func Newl(r *Renderer) {
	r.buf.WriteByte('\n')
	r.lines++
}

// RenderAutogen format collected code with header comment about being autogenerated and advice
// not to touch it manually
func RenderAutogen(r *Renderer, appName, comment, pkg string, imports []ImportsGroup) (io.Reader, error) {
	autoGen := fmt.Sprintf("Code generated with %s. DO NOT EDIT.", appName)
	return r.render([]string{autoGen, comment}, pkg, imports)
}

// Render format collected code with given package comment
func Render(r *Renderer, pkgComment, pkg string, imports []ImportsGroup) (io.Reader, error) {
	return r.render([]string{pkgComment}, pkg, imports)
}

func (r *Renderer) render(pkgComment []string, pkg string, imports []ImportsGroup) (io.Reader, error) {
	var buf bytes.Buffer
	for _, cmt := range pkgComment {
		cmt = strings.TrimRight(cmt, "\n")
		switch strings.Count(cmt, "\n") {
		case 0:
			if cmt != "" {
				buf.WriteString("// ")
				buf.WriteString(cmt)
				buf.WriteString("\n\n")
			}
		default:
			buf.WriteString("/*\n")
			buf.WriteString(cmt)
			buf.WriteString("\n*/\n\n")
		}
	}
	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString("\n\n")

	if len(imports) > 0 && len(imports[0]) == 1 && imports[0][0].Path == "C" {
		buf.WriteString("import \"C\"\n\n")
		imports = imports[1:]
	}
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for i, g := range imports {
			if i > 0 {
				buf.WriteByte('\n')
			}
			for _, imp := range g {
				buf.WriteString("    ")
				if imp.Alias != "" {
					buf.WriteString(imp.Alias)
					buf.WriteByte(' ')
				}
				buf.WriteByte('"')
				buf.WriteString(imp.Path)
				buf.WriteString("\"\n")
			}
		}
		buf.WriteString(")\n\n")
	}
	lineCount := bytes.Count(buf.Bytes(), []byte("\n"))

	_, _ = io.Copy(&buf, &r.buf)

	fset := token.NewFileSet()
	p, err := parser.ParseFile(fset, "", &buf, parser.AllErrors|parser.ParseComments)
	if err != nil {
		var errStrace string
		var errLine int
		var errEnd int
		if p != nil {
			ast.Inspect(p, func(node ast.Node) bool {
				switch v := node.(type) {
				case *ast.BadDecl:
					errLine, errStrace = r.locateErrorReason(fset.Position(v.Pos()).Line, lineCount)
					errEnd = fset.Position(v.End()).Line
					return false
				case *ast.BadExpr:
					errLine, errStrace = r.locateErrorReason(fset.Position(v.Pos()).Line, lineCount)
					errEnd = fset.Position(v.End()).Line
					return false
				case *ast.BadStmt:
					errLine, errStrace = r.locateErrorReason(fset.Position(v.Pos()).Line, lineCount)
					errEnd = fset.Position(v.End()).Line
					return false
				}

				return true
			})
		}
		var errs scanner.ErrorList
		var shortErr error
		if errors.As(err, &errs) {
			for _, e := range errs {
				shortErr = errors.New(e.Msg)
				if errStrace == "" {
					errEnd = e.Pos.Line
					errLine, errStrace = r.locateErrorReason(errEnd, lineCount)
				}
				break
			}
		}

		txt := strings.Split(buf.String(), "\n")
		txtBottomLine := strconv.Itoa(len(txt))
		numberWidth := len(txtBottomLine)
		lineFmt := "%0" + strconv.Itoa(numberWidth) + "d"
		var errMsg bytes.Buffer
		errMsg.WriteString(err.Error())
		errMsg.WriteString("\n\n")
		for i, line := range txt {
			_, _ = fmt.Fprintf(&errMsg, lineFmt, i+1)
			if line != "" {
				errMsg.WriteString(": ")
				errMsg.WriteString(line)
				errMsg.WriteByte('\n')
			} else {
				errMsg.WriteString(":\n")
			}
		}
		_, _ = io.Copy(os.Stderr, &errMsg)

		if shortErr != nil {
			_, _ = os.Stderr.WriteString(errStrace + "\n")

			lines := strings.Split(buf.String(), "\n")
			lines = lines[errLine : errEnd+1]
			err = errors.New(shortErr.Error() + "\n" + strings.Join(lines, "\n"))
		}

		return nil, err
	}

	var result bytes.Buffer
	printConfig := &printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}
	if err := printConfig.Fprint(&result, fset, p); err != nil {
		return nil, err
	}

	return &result, nil
}

// RawString извлечение сырых накопленных данных в виде строки
func RawString(r *Renderer) string {
	return r.buf.String()
}

// RawBytes извлечение сырых накполенных данных в виде слайса байт
func RawBytes(r *Renderer) []byte {
	return r.buf.Bytes()
}
